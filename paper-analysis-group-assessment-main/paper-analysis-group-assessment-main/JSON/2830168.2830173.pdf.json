{"TYPE": "document", "VALUE": [{"TYPE": "body", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Testing and Debugging Exascale Applications by Mocking MPI"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thomas Clune "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "NASA Goddard Space"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 432, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Flight Center"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 784, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Greenbelt, MD 20771"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 590, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "thomas.l.clune@nasa.gov"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 378, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Hal Finkel "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Leadership Computing "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Facility "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Argonne National "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Laboratory "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "9700 South Cass Avenue Building 240 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Argonne, IL 60439 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "hfinkel@anl.gov"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Michael Rilee Rilee Systems"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 576, "right": 864, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Technologies LLC and"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 200, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "NASA GSFC "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "PO Box 5532 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Derwood, MD 20855 michael.l.rilee-"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "1@nasa.gov"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 288, "right": 432, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ABSTRACT"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Debugging and code verification present daunting challenges for message-passing parallel applications that employ bil-lions of processes/threads. Yet often it is only at scale that software defects first show themselves. When it is di\ufffdcult or impossible to replicate problems on small scale platforms, development delays and resource costs are significant consid-erations."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 276, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Software mocks, in which reconfigurable components re-place dependencies in an application component under test, are a powerful and versatile way to side-step expensive, com-plex, and/or otherwise impractical dependencies. We pro-pose that mocking application dependencies, and MPI in particular, is an e\u21b5ective technique for testing and debug-ging exascale message-passing software using small-scale com-puting resources."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "and formal methods for development continue to make ad-mirable progress[8], testing and debugging generally remain quite expensive both in terms of the consumption of dedi-cated computing resources and in terms of wasted developer time due to delays in availability of such large resources.[4] In an ideal world, all software defects could be exhibited using modestly sized computational domains and small numbers "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "However, real-world experience has of processes/threads."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 202, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "shown that bugs are all-too-often first detected when ex-tending an application to larger domains and/or computing platforms. Further, even once a defect has been detected and isolated, the creation of a small-scale reproducer can require precise understanding of the nature of the problem to preserve the salient characteristics. Thus, problems must often be largely resolved at-scale before a proper small-scale reproducer can be crafted."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 202, "right": 20, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Categories and Subject Descriptors"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1.1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 104, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Scenarios"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 134, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D.2.4 [Software/Program Verification]: Model check-ing-Assertion checkers; D.2.5 [Testing and Debugging]: Distributed debugging -Error handling and recovery"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 240, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "General Terms"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Reliability; Verification"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "We list here some representative scenarios in which tra-ditional approaches to testing and/or debugging of exascale applications would appear to require the use of large-scale computing resources:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 20, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Serial algorithmic performance."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "When the measured performance (speed or memory foot-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 418, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Keywords"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "print) of an algorithm diverges from prediction, profiling tools may be insu\ufffdcient to completely identify and correct"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 2016, "right": 2, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "software verification; mock objects; MPI; exascale"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "INTRODUCTION"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Verification and debugging are some of the most di\ufffdcult"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 180, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "challenges faced when developing software to be run on exas-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "cale systems. And while static analysis, relative debugging,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Permissiontomakedigitalorhardcopiesofallorpartofthisworkfor personalorclassroomuseisgrantedwithoutfeeprovidedthatcopiesare notmadeordistributedforprofitorcommercialadvantageandthatcopies bearthisnoticeandthefullcitationonthefirstpage.Tocopyotherwise,to republish,topostonserversortoredistributetolists,requirespriorspecific permission and/or a fee. Request permissions from Permissions@acm.org. SEHPCCSE '15, November 20, 2015, Austin, Texas, United States."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Copyright 2015 ACM ISBN 978-1-4503-4012-0/15/11...$15.00 DOI: http://dx.doi.org/10.1145/2830168.2830173"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 720, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "5"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 28, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "structures that are created and populated by some initial-ization layer of an application. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Even if the routine to be tested is itself completely serial and thus has no direct de-pendency on MPI, there can still be an induced dependency in the corresponding tests due to MPI procedure calls in the initialization logic for the application. Configuring the ini-tialization to produce realistic large-scale data structures to drive the control logic on a small number of processes is not possible in many cases and the developer must then choose between enhancing the initialization to support testing and creating a custom variant. As a trivial example consider the case where the size of the local data structure is a nonlinear function of the grid size."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Error handling/trapping."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Consider an application that attempts to trap and fail gracefully when MPI procedures return with an error code."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "APPROACH "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "In software engineering parlance, a \"mock\" is an interface, or collection of interfaces, that can be used to replace a dependency within a software system[6]. Mocks are not in-tended to be fully functional, but rather to facilitate testing in the presence of complex and/or expensive dependencies. Mocks can be used to verify that correct data is sent to an external dependency and can be configured to produce predictable return values from an external dependency. A canonical example of the use of mocks is for tests of software that modifies large/important databases. In addition to the large overhead for connecting to a real shared database, tests would undesirably modify values in the database and could not rely on existing values in the database. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Mocks pro-vide an appropriate sandbox to ensure that the procedures which interact with the database are correctly implemented without the cost and risk of working directly with the main"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Such a policy is especially valuable for MPI I/O procedures "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "database."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "due to inherent uncertainties in the state of the file system. MPI errors are more frequent at high process counts due in part to the total number of procedure calls, but also due to larger bu\u21b5ers, greater complexity, and hot-spots in the communication fabric. Verification that an application cor-rectly detects and handle these failures is di\ufffdcult as small use cases may rarely or possibly never generate the necessary conditions."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 242, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Deadlock and Race Conditions?."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "As with explicit failure signals from MPI, race conditions become increasingly likely as applications scale to larger numbers of processors. Ensuring that race conditions are correctly guarded against, or debugging a procedure in which a race condition is suspected, therefore generally involves running a large scale scenario."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 236, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Mocking MPI "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Mocking MPI, at a high level, allows a test that only uses a few processes (perhaps just one) to act as though they are part of a much larger group. This capability is somewhat di\ufffdcult to create as MPI makes its callers explicitly aware of the size of each communicator (group of processes), and requires that each group must be complete in order to func-tion (e.g., collectives). Nonetheless, MPI is the standardized interface for distributed-memory parallelism in high perfor-mance computing (HPC), and direct uses of MPI are per-vasive throughout many important exascale applications. It is therefore impractical to insist that all HPC applications hide MPI within abstractions such as Charm++[7], Peb-bles[10], and AM++[9]. Mocking can of course be equally useful in those contexts, and presumably considerably easier"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 236, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1.2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Goals"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 134, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "to implement."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 3664, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Developers who are unfamiliar with the technique of mock-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this paper we propose a methodology that enables the development of unit tests that can be used to verify correct"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ing often initially confuse it with \"stubbing\". Stubbing is a technique to provide a trivial implementation of some in-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "software behavior for scenarios such as those discussed above"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "terface for the purpose of aiding portability."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 256, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "E.g."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "many"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 98, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "while utilizing only a single process executing on a single node (i.e., in the extreme case, one could attempt to verify many aspects of an exascale application on a simple laptop with su\ufffdcient memory.) In particular we expect to be able to verify software characteristics such as:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 240, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 serial performance and memory consumption\u2022 correct loop bounds"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "\u2022 correct topology of neighbor processes"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "\u2022 existence/size of messages from other processes\u2022 error handling / fault tolerance"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "\u2022 race conditions and deadlock"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 266, "right": 720, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Note that we are not suggesting that this methodology"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "packages contain a stub of MPI which provide one-process behavior for the restricted subset of MPI used by the pack-age. This can reduce the installation di\ufffdculty for new users and/or permit deployment of an application in environments that lack MPI or restrict its use. Whereas stubbing provides a trivial but technically correct implementation for some subset of MPI, mocking attempts to emulate the behavior of many MPI processes while providing essentially none of the actual functionality. Each test configures the mock layer such that calls to MPI processes return predetermined syn-thetic values that are intended to probe other aspects of the procedure being tested. The technique is powerful but sub-tle and therefore requires some experience and thought to exploit."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 30, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "To mock MPI the infrastructure must provide mechanisms for configuring the apparent behavior of nonexistent pro-cesses. Often this behavior is trivial: broadcasts and sends to nonexistent ranks can be ignored, barriers can be assumed"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 30, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "would eliminate all requirements for testing and debugging "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "to have been reached, and so on. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Emulating the contri-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "at scale, but rather that it has the potential to significantly "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "bution of nonexistent ranks to reduction operations is not"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "reduce such needs. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Also note that mocking is inherently "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "particularly di\ufffdcult. The most complicated aspect is the"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "unable to diagnose problems in the the implementation of the MPI layer itself except insofar as to aid in eliminating other possibilities."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 30, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 28, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "of procedure calls, each with a separately configurable set of "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Mocking is generally easier to implement and use in an"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "outputs. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "object-oriented context where dependency injection (DI) be-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "As with many other mocking scenarios, a potentially sig-nificant complication for the implementer of the mock ser-vice is the di\ufffdculty in manipulating private data structures defined within the code under test (e.g., if the code involves a complicated data structure for which an MPI data type has been constructed, it can be di\ufffdcult for the mock service to take appropriate actions without implementing a substan-tial subset of MPI's type management system.) Allowing the test implementer to use the existing definitions of these entities is essential to creating a practical solution."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 240, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The good news is that in many MPI applications, any given process primarily communicates with only a small number of neighbors with the major exception being rela-tively simple global broadcasts and reductions. So the num-ber of non-existent ranks that will have relevant non-trivial behavior to emulate is quite limited. Yet two important is-sues requiring more e\u21b5ort are: user-defined data types and complex sequences of data exchanges."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 240, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "comes a powerful technique. DI exposes dependencies within a system under test enabling them to be readily replaced with configurable mock behaviors. Indeed, several mocking frameworks (e.g. Google Mock[1], Hippo Mocks[2], mock-cpp[3]) exist for C++ and could be more-or-less directly applied to mock MPI. These frameworks generally combine preprocessor directives and templating to allow developers to instantiate mock objects with a relatively modest amount of source code. They provide flexible means for configuring the outputs and specifying the expected input parameters to a sequence of calls to the layer being mocked."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 20, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The situation for Fortran is a bit more bleak at the mo-ment. We (Clune and Rilee) have made some initial steps to introduce mocking capabilities within pFUnit[5], a unit testing framework for Fortran with MPI. While Fortran now supports object-oriented programming, it still lacks suit-able templating capabilities comparable to those of C++, and therefore requires considerably more manual e\u21b5ort on"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 20, "firstLine": 180}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "As a pedagogical example of our proposed methodology,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 96, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "the part of developers to instantiate mock objects."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 256, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Re-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 2, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "consider a test in which we wish to \"fool\" the application into thinking that it is running in an environment with Np processes on rank r. A prototype mock MPI implementation might look something like the following for MPI_Comm_rank()"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 238, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "gardless of this, the standard interfaces for MPI, except for the now-deprecated C++ interfaces, are procedural. This means that rather than using mock-objects for dependency injection, we must resort to reconfiguring an application at"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 236, "right": 20, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "with an analogous implementation for MPI_Comm_size():"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "the link-step with a mock-library."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 356, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Further, to accommo-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 86, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "subroutine MPI_Comm_rank(comm, rank, ierr) use MockMPI, only: mock "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "integer, intent(in) :: comm "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "integer, intent(out) :: rank, ierr"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 282, "right": 1008, "hanging": 282}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call mock%verify('MPI_Comm_rank', 'comm', comm) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call mock%get('MPI_Comm_rank', 'rank', rank) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call mock%get('MPI_Comm_rank', 'ierr', ierr) end subroutine MPI_Comm_rank"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "date some use-cases in which user-defined state must be saved/compared/restored, users must be prepared to con-struct helper procedures that are passed into the mock li-brary as part of the configuration step."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 280, "right": 20, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "EXAMPLES "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "We consider here some highly-simplified examples that are representative of realistic di\ufffdculties encountered when test-ing complex parallel software."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 280, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "A test for a procedure proc() might then configure the mock"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 104, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Error trapping"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 134, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "to behave as rank 4 of a 10 process execution in a manner like:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "use MockMPI, only: mock "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "call mock%set('MPI_Comm_size','npes', 10) call mock%set('MPI_Comm_rank','rank', "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "4)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1152, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Suppose we wish to test whether or not a procedure cor-rectly traps a certain unsuccessful MPI return code within a given procedure. Arranging for MPI to routinely fail in that particular manner might be di\ufffdcult or even impossible, but we can configure the mock to do so as part of such a test:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 20, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "... "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "use MockMPI, only: mock, MPI_ERR_TAG"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "call proc(...) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call mock%set('MPI_iSend','ierr', MPI_ERR_TAG)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "< check results >"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The set() methods store values for procedure output pa-rameters for later retrieval by the get() methods. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "The verify() method can detect whether an input parameter matches previously set expectations, if any."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Note that this style of testing can also be very useful in non-exascale contexts. Also note that we are not advocating this particular implementation approach for mock MPI; it is only meant to be suggestive, easily understood, and fit within the 2-column format."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 240, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "A complete implementation of a mock layer for MPI would be a require a significant e\u21b5ort, though with far less com-plexity than the implementation of MPI itself. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "However, just as with MPI, many applications would only require a relatively modest subset of interfaces to be supported for practical use."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "call proc_that_should_trap(...) @assertExceptionRaised(...)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 1872, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Complex data types "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "While standard approaches for manipulating procedure parameters su\ufffdce in cases where the types are fixed (e.g.,'rank', 'recvcounts', etc.), a generic implementation of a mock MPI will be unable to directly manipulate bu\u21b5er pa-rameters. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Instead, users will likely be required to create and pass to the mock a set of small auxiliary procedures that save/compare/restore values for the types actually be-ing used. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "(Possibly the cretaion of these could be semi-automated through some sort of templating preprocessor.) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Suppose we wish to test a procedure which receives ele-ments 1 and 3 an array of type UserDefined in a call to MPI_Recv. If the user type is defined by:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 238, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Available technologies"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 134, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "type UserDefined"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1640, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "real :: tau"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1828, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "7"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 5134, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "integer :: n "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "end type UserDefined"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 3024, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "then synthetic values can be specified in a test:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "subroutine test_complicated() "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "type (UserDefined) :: x(4) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "x(1) = UserDefined(2.5, 5) !synthetic "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "x(3) = UserDefined(3.5, 8) !synthetic "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "call mock%set('MPI_Recv', 'rbuf', custom_set, x) call complicated_procedure(...) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "..."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 282, "right": 144, "hanging": 282}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "end subroutine test_complicated"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The aux. procedure custom_set() is defined as:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "subroutine custom_set(addr, rbuf) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "! sets elements 1 and 3 of rbuf "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (c_ptr) :: addr "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (UserDefined) :: rbuf(4) "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (UserDefined), pointer :: saved_buf "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call c_f_pointer(addr, saved_buf, [4]) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "rbuf(1) = save_buf(1) "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "rbuf(3) = save_buf(3) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "end subroutine custom_set"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 864, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.3 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Race condition "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "At first glance, race conditions would appear to be dif-ficult or even impossible to address with the methodology advocated in this paper. This is because the observed in-correct behavior can be on a process that executing correct code, and processes with incorrect code may behave cor-rectly with regard to the values of its data. However, with a modest amount of ingenuity, it is possible to configure the MPI mock to detect such code defects."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this example we demonstrate a test that is meant to ensure that a call to MPI_Wait() is executed after a call to MPI_Isend() and priort to any local modification of that"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 244, "firstLine": 180}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "CONCLUSION "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Verification of software running on billions of cores is ex-pected to be a serious barrier to scientific productivity on anticipated exascale platforms. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Traditional approaches to testing and debugging on bleeding edge machines are ex-pensive and present significant bottlenecks for productivity. Applying the methodology of software mocking in this en-vironment may significantly improve the rate at which MPI applications can be developed, tested, and verified. By sim-ulating the parallel context experienced by a single process within the application, developers can then routinely test and investigate code behavior on relatively modest comput-ing resourced during routine software development."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 234, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "5. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "REFERENCES "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[1] Google c++ mocking framework."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 234, "right": 1728, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\"http://code.google.com/p/googlemock\". Accessed: 2015-0815."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 610, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[2] Home - hippo mocks project - assembla."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 326, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": ". Accessed: 2015-0815."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 610, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[3] mockcpp - a c/c++ mock framework."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 326, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\"http://code.google.com/p/mockcpp\". Accessed: 2015-08-15, also: "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "https://bitbucket.org/godsme/mockcpp."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 610, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[4] Tools for exascale computing: Challenges and "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "strategies. U.S. Department of Energy, O\ufffdce of "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Science \"http://science.energy.gov/~/media/ascr/ pdf/research/cs/Exascale%20Workshop/Exascale_ Tools_Workshop_Report.pdf\", 2011."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 610, "right": 0, "hanging": 284}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[5] T. Clune and M. Rilee. pFUnit 3.0 - a unit testing "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "framework for parallel fortran software."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 326, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": ", 2014. Accessed: 2014-07-08."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 610, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "bu\u21b5er: "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "[6] M. Feathers. Working E\u21b5ectively with Legacy"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "type (my_type) :: sbuf "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "call mock%set('MPI_Isend', 'sbuf', sbuf, capture) call mock%expect_call('MPI_Wait', compare) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "call code_with_race(sbuf) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "call mock%verify_all()"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The auxiliary procedure capture() saves the address of the passed bu\u21b5er as well as a copy of the data during the call to MPI_Isend(), whereas compare() verifies that the bu\u21b5er still contains the same values during MPI_Wait()."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 30, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "module custom_mod "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (C_PTR), save :: save_addr "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (my_type), save :: sbuf_save "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "contains "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "subroutine capture(sbuf_addr) "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (C_PTR), intent(in) :: sbuf_addr "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (my_type), pointer :: sbuf "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "save_addr = sbuf_addr "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call c_f_pointer(sbuf_addr, sbuf) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "sbuf_save = sbuf "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "end subroutine capture "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "subroutine compare() "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "type (my_type), pointer :: sbuf "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "call c_f_pointer(sbuf_addr, sbuf) "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "@assertEqual(sbuf_save, sbuf) "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "end subroutine compare "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "end module custom_mod"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 720, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "8"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 28, "right": 0, "firstLine": 0}}}]}]}
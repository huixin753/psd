{"TYPE": "document", "VALUE": [{"TYPE": "body", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine for Simulating"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Quantum Circuits at Exascale"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "THIEN NGUYEN, Quantum Computing Institute, Oak Ridge National Laboratory, USA and Com-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "puter Science and Mathematics Division, Oak Ridge National Laboratory, USA"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "DMITRY LYAKH, Quantum Computing Institute, Oak Ridge National Laboratory, USA and National"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Center for Computational Sciences, Oak Ridge National Laboratory, USA "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "EUGENE DUMITRESCU, Quantum Computing Institute, Oak Ridge National Laboratory, USA"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "and Computational Sciences and Engineering Division, Oak Ridge National Laboratory, USA DAVID CLARK, NVIDIA Corp., USA "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "JEFF LARKIN, NVIDIA Corp., USA "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "ALEXANDER MCCASKEY, Quantum Computing Institute, Oak Ridge National Laboratory, USA"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "and Computer Science and Mathematics Division, Oak Ridge National Laboratory, USA"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The numerical simulation of quantum circuits is an indispensable tool for development, verification and validation of hybrid quantum-classical algorithms intended for near-term quantum co-processors. The emergence of exascale high-performance computing (HPC) platforms presents new opportunities for pushing the boundaries of quantum circuit simulation. We present a modernized version of the Tensor Network Quantum Virtual Machine (TNQVM) which serves as the quantum circuit simulation backend in the eXtreme-scale ACCelerator (XACC) framework. The new version is based on the scalable tensor network processing library ExaTN (Exascale Tensor Networks). It provides multiple configurable quantum circuit simulators which perform either an exact quantum circuit simulation via the full tensor network contraction or an approximate simulation via a suitably chosen tensor factorization scheme. Upon necessity, stochastic noise modeling from real quantum processors is incorporated into the simulations by modeling quantum channels with Kraus tensors. By combining the portable"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 170, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "This manuscript has been authored by UT-Battelle, LLC under Contract No. DE-AC05-00OR22725 with the U.S. Department of Energy. The United States Government retains and the publisher, by accepting the article for publication, acknowledges that the United States Government retains a non-exclusive, paid-up, irrevocable, world-wide license to publish or reproduce the published form of this manuscript, or allow others to do so, for United States Government purposes. The Department of Energy will provide public access to these results of federally sponsored research in accordance with the DOE Public Access Plan. (http://energy.gov/downloads/doe-public-access-plan)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Authors' addresses: Thien Nguyen, nguyentm@ornl.gov, Quantum Computing Institute, Oak Ridge National Laboratory, Oak Ridge, TN, USA and Computer Science and Mathematics Division, Oak Ridge National Laboratory, Oak Ridge, TN, USA; Dmitry Lyakh, Quantum Computing Institute, Oak Ridge National Laboratory, Oak Ridge, TN, USA and National Center for Computational Sciences, Oak Ridge National Laboratory, Oak Ridge, TN, USA; Eugene Dumitrescu, Quantum Computing Institute, Oak Ridge National Laboratory, Oak Ridge, TN, USA and Computational Sciences and Engineering Division, Oak Ridge National Laboratory, Oak Ridge, TN, USA; David Clark, NVIDIA Corp., Santa Clara, CA, USA; Jeff Larkin, NVIDIA Corp., Santa Clara, CA, USA; Alexander McCaskey, mccaskeyaj@ornl.gov, Quantum Computing Institute, Oak Ridge National Laboratory, Oak Ridge, TN, USA and Computer Science and Mathematics Division, Oak Ridge National Laboratory, Oak Ridge, TN, USA."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 160, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM acknowledges that this contribution was authored or co-authored by an employee, contractor, or affiliate of the United States government. As such, the United States government retains a nonexclusive, royalty-free right to publish or reproduce this article, or to allow others to do so, for government purposes only."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u00a9 2022 Association for Computing Machinery."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 160, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2643-6817/2022/7-ART $15.00 "}, {"TYPE": "Break"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 6768, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 76, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "XACC quantum programming frontend and the scalable ExaTN numerical processing backend, we introduce an end-to-end virtual quantum development environment which can scale from laptops to future exascale platforms. We report initial benchmarks of our framework which include a demonstration of the distributed execution, incorporation of quantum decoherence models, and simulation of the random quantum circuits used for the certification of quantum supremacy on Google's Sycamore superconducting architecture."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 172, "right": 0, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "INTRODUCTION"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Quantum circuit simulation on classical computers is an important tool for development, verification, validation, and analysis of quantum algorithms in the noisy intermediate-scale quantum (NISQ) regime [33]. There exist a wide variety of simulation techniques that have been developed for this purpose, ranging from the state vector [10, 17, 19] or density matrix [23] simulators to Clifford-based [2, 6-8, 13] and tensor-based simulators [16, 20, 24-26, 34, 37, 38]. In particular, the tensor network based techniques have proven their power in constructing effective simulators of rather large quantum circuits with memory requirements that scale in accordance with the quantum state entanglement properties [26, 34]. More generally, tensor processing has been recognized as a computing technique applicable to many scientific and engineering domains [14, 18, 35, 36] that has resulted in highly-optimized software leveraging the state-of-the-art classical hardware capabilities to simulate complex physical phenomena [32]."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 144, "firstLine": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The tensor network quantum virtual machine (TNQVM) was first introduced in [26] as a tensor-network-based quantum circuit simulation back-end for the XACC framework [27]. The original implementation leveraged the matrix product state (MPS) representation of the quantum circuit wave-function based on the data structures provided by the ITensor library [11] - a popular library that (at the time of implementation) only supported single-core CPU execution. In this work, we present an enhanced TNQVM implementation with a direct focus on the modern HPC deployment via the utilization of the state-of-the-art Exascale Tensor Networks (ExaTN) library [1] as the computational backend. This re-architected TNQVM code runs on both CPU and GPU hardware, and supports multi-node, multi-GPU execution contexts. One of the primary drivers of this work is the need for a flexible high-performance simulator that can (1) extract experimentally verifiable results from large quantum circuits, and (2) take full advantage of computing resources by devising custom strategies for each simulation task and balance the workload (memory and compute) across all available resources."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor network theory is a natural fit for large-scale quantum circuit simulations. Quantum computers encode computation and information in an exponentially large tensor space which is not directly accessible experimentally. One can only collect discrete observable statistics on a given quantum state (qubit measurement bit-strings, expectations values, etc.). The tensor network theory provides the most natural way of dealing with the exact and approximate tensor representations in such exponentially large spaces, thereby enabling an efficient expression of the quantum state observable quantities. Combined with a low-rank compression via low-order tensor factorizations, this approach also becomes highly amenable to memory-bound flop-oriented compute platforms, which most of the current HPC systems are. Thus, the main goal of the TNQVM code is to provide an implementation of a set of tensor network algorithms which are well-suited for quantum circuit simulations in different use case scenarios. All necessary construction, manipulation, and processing of the derived tensor networks is automated via the ExaTN backend. Importantly, the ExaTN backend also provides the foundation for the numerical processing workload optimization. Not only can we"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 80, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "describe quantum circuits in various tensor network forms, such as matrix product state (MPS) [30], tensor tree network (TTN) [36], etc., but we can also delegate the runtime execution optimization to ExaTN where it can decompose and schedule the tensor processing tasks across all available resources, including multi-core CPUs, GPUs, and potentially more specialized accelerators (details of the ExaTN library will be described in an upcoming publication)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "In this manuscript, we present implementation details and some preliminary results for the following TNQVM capabilities:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 A generic tensor network contraction based simulator that expresses and evaluates the entire "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "quantum circuit as a tensor network (including expectation values)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 A distributed-memory MPS-factorized state-vector simulator."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 A density matrix (noisy) simulator based on the hierarchical tensor network or locally-purified "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "matrix product operator representations."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 An automatic divide-and-conquer tensor network reconstruction simulator based on arbitrary "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "tensor network factorization schemes with a target fidelity control."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "We note that the generic tensor network contraction based simulator supports both noiseless and noisy simulations - we use tensor networks to represent either the state vector or density matrix evolution, respectively. The noise-modelling operations expressed in terms of the channel (Kraus) operators can be incorporated into the latter to mimic the hardware noise models. Similarly, approximate tensor representations of pure or mixed quantum states, based on different tensor factorizations, are provided as alternative approaches geared towards larger-scale simulations. In essence, TNQVM provides a multi-modal simulation platform whereby one can quickly prototype and evaluate accuracy, runtime, parallelism, memory consumption, etc., of varying tensor-based approaches for quantum circuit simulation, as well as execute the actual production runs on workstations, HPC platforms and clouds."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Compared to many other available quantum circuit simulation platforms, the XACC-TNQVM-ExaTN software stack offers unique features in terms of scalability, flexibility, extensibility, performance, and availability. There are not many quantum circuit simulators that have been rigorously tested in a state-of-the-art HPC environment. For example, the Flexible Quantum Circuit (qFlex) Simu-lator [37, 38] and the QCMPS simulator [9] have demonstrated scalability and accuracy on large supercomputers for the contraction-based and MPS simulation approaches, respectively. However, both of these simulators have been developed for rather specific and narrow use cases, not targeting generic quantum circuit simulation workflows in a complete end-to-end quantum programming stack. Moreover, most tensor-based simulators, including qFlex and QCMPS, tend to associate their internal representation to a particular form of tensor networks as opposed to the multi-modal flexibility of TNQVM. Very recently, classical simulations of the random quantum circuits used in Google's quantum supremacy experiments [5] have been revisited with new simulators leveraging a powerful tensor contraction path optimization algorithm [16]. The QUIMB [15] and ACQDP [20] simulators have positioned themselves as potentially the fastest simulators for the quantum supremacy circuits on distributed HPC platforms and clouds. Although they can be used for simulating other quantum computing circuits as well, their main focus has so far been on the direct tensor network contraction technique and noiseless amplitudes. Similarly, two other recent quantum circuit simulators based on tensor network representations, Jet [39] and QTensor [24], have also focused on the direct tensor network contraction algorithm. In particular, QTensor has demonstrated significant GPU acceleration"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 72, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "for the Quantum Approximate Optimization Algorithm (QAOA) via the new NVIDIA cuPy backend. In contrast, to further boost its GPU performance, TNQVM has been integrated with the cuTensorNet library from the NVIDIA cuQuantum framework [29]."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Last but not least, we note that the modular full-stack integration between XACC, TNQVM, and ExaTN allows us to support multiple quantum programming languages and run on different classical compute platforms seamlessly. This full-stack integration proves beneficial, especially for the TNQVM noisy simulators, which can query device noise models directly from the cloud-based hardware providers, e.g., IBM, using the XACC remote connection capabilities. Finally, we also want to stress our commitment to open-source development principles. All of our development activities and implementations are in the public domain under permissive licenses."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "To summarize, this work makes the following contributions:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 374, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 We present an end-to-end C++ system for quantum circuit expression and simulation with a "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "full support of heterogeneous HPC platforms."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 We introduce multiple levels of parallelization in tensor network processing via our new ExaTN "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "library."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 We design and implement a scheme to parallelize MPS simulations across MPS sites. This "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "scheme differs from the prior work which parallelized each contraction in such simulations.\u2022 We provide the ability to import and incorporate device noise models into quantum circuit "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "simulations."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 We provide the capability of performing locally-purified MPO simulations with explicit noise "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "modeling."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 We introduce a novel general tensor network reconstruction (ExaTN-Gen) simulation method. To the best of our knowledge, we are the first to employ this technique for quantum circuit simulations."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 656, "right": 0, "hanging": 172}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The subsequent sections are organized as follows. Section 2 provides some background information about the XACC programming framework (TNQVM frontend) and the ExaTN library, the scalable numerical backbone behind TNQVM. Section 3 details the implementation of various simulators in TNQVM in terms of the tensor language used by ExaTN. Section 4 provides examples and demonstration results of TNQVM for various tasks ranging from a large-scale quantum circuit simulation to noisy quantum circuit modeling. Conclusions and outlooks are given in Section 5."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "BACKGROUND"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "ExaTN library"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The ExaTN library (Exascale Tensor Networks) provides generic capabilities for construction, ma-nipulation and processing of arbitrary tensor networks on single workstations, commodity clusters and leadership supercomputers [1]. On heterogeneous platforms, it can leverage GPU acceleration provided by NVIDIA GPUs (support of AMD GPUs is still experimental). Our TNQVM simulator uses the ExaTN library as a parallel tensor processing backend. The native ExaTN C++ application pro-gramming interface (API) consists of declarative and executive API (partial Pybind11 [21] bindings are available for Python users). The declarative API provides functions for constructing arbitrary tensors and tensor networks and performing different formal manipulations on them. The executive API provides functions for allocating tensor storage and parallel processing of tensor networks, for example to perform tensor network contraction. The latter operation is automatically decomposed"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 80, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "5"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "by the ExaTN parallel runtime into smaller tasks which are distributed across all MPI processes. The decomposition is performed via the standard technique of intermediate tensor slicing [16, 38]. Individual tensor network slices received by each MPI process are further decomposed into pairwise tensor contractions by a pluggable contraction path finder. The pairwise contractions are then subsequently appended into the dynamic directed acyclic graph (dynamic DAG) executed by the ExaTN parallel runtime in a fully asynchronous fashion on all available compute units (CPUs and GPUs)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ExaTN also provides API for higher-level algorithms, specifically for tensor network reconstruction and tensor network optimization. Tensor network reconstruction allows approximation of a given tensor network by another tensor network, normally with a simpler structure. Tensor network optimization allows finding extrema of a given symmetric tensor network functional (expectation value of some tensor operator). The provided capabilities are sufficient for reformulating common linear algebra procedures on low-rank tensor network manifolds. Such a low-rank compression of linear algebra procedures allows their efficient computation for rather large problems with a tiny fraction of their exact Flop and memory cost."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 168, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "XACC quantum programming framework"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "XACC is a system-level quantum programming framework that enables quantum-language-agnostic programming targeting multiple physical and virtual quantum backends via a novel quantum intermediate representation (IR) [3]. Ultimately, XACC puts forward a service-oriented architecture and defines a number of interfaces or extension points that span the typical quantum-classical programming, compilation, and execution workflow. This platform provides an extensible backend interface for quantum program execution in a retargetable fashion, and this is the interface we target for this work. TNQVM directly extends this layer and enables execution of the XACC IR via multiple tensor-network simulation schemes."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Here, we briefly summarize pertinent XACC interfaces that are relevant to TNQVM and direct interested readers to [27] for a comprehensive introduction. At the high-level, we can classify the framework components into three categories, namely frontend, middle-end, and backend. The fron-tend exposes a Compiler interface which is responsible for converting the input kernel source strings to the XACC IR. IR is a pertinent data structure of the framework, capturing both the Instruction and CompositeInstruction service interfaces specialized for concrete quantum gates and collec-tions of those gates, respectively. Using the IR representation of the quantum kernel as its core data structure, the middle-end layer also exposes an IRTransformation interface enabling general transformations of quantum circuits (CompositeInstruction) for tasks such as circuit optimization and qubit placement. Lastly, XACC provides an Accelerator interface enabling integration with physical and virtual (simulator) quantum computing backends. TNQVM implements this Accelerator interface, thus providing a universal virtual quantum backend for the framework. In other words, one can use TNQVM interchangeably with other physical QPUs or simulators available in XACC."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Internally, XACC Accelerator implementations usually leverage the object-oriented visitor pattern (the XACC InstructionVisitor) [12] to walk the IR tree representation of the compiled quantum circuits. Each Accelerator may opt to perform different actions while walking the IR tree. For instance, for physical hardware backends, the Accelerator adapter needs to convert XACC IR to the native gate set that the platform supports. As we will describe in detail later in the text,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 146, "firstLine": 208}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 76, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "TNQVM makes use of this InstructionVisitor interface to construct different tensor network representations of the input circuit depending on the selected mode of simulation, e.g., exact or approximate, ideal or noisy simulation, etc."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 168, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "EXATN-ENABLED TNQVM IMPLEMENTATION"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The ultimate goal of our updated TNQVM implementation targeting heterogeneous HPC systems is to map the input XACC IR to unique tensor data structures provided by ExaTN via the XACC InstructionVisitor. TNQVM will walk the IR tree via custom visitors (visitor design pattern [12] as described in 2.2) and visit the IR nodes (quantum gates) and construct, evaluate, and post-process the corresponding ExaTN tensor and tensor network objects. Broadly speaking, TNQVM simulation methods can be categorized as either exact or approximate. The first category comprises backend simulators (visitors) that faithfully translate quantum circuits to equivalent tensor networks and then contract them to evaluate the value of interest. On the other hand, approximate simulation methods rely on factorized forms of the state vector or density matrix where some form of a tensor network compression is used, for example, via the matrix product-state (MPS) tensor network or other tensor network topologies. The factorized representation is maintained throughout the circuit simulation via a suitable decomposition procedure. Thus, we can balance the accuracy and complexity of these approximate representations throughout the simulation process. We note that TNQVM can incorporate stochastic noise into both forms of quantum circuit simulation."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 168, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Direct Tensor Network Contraction"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this mode of execution, we construct a tensor network that embodies the entire quantum circuit before evaluating it numerically. More specifically, qubits, single-qubit gates, and two-qubit gates are represented by rank-1, rank-2, and rank-4 tensors, respectively, as depicted in Fig. 1a. The quantum circuit dictates the connectivity of tensors within the tensor network (see Fig. 1b). Once completed, the tensor network is submitted to the ExaTN numerical server for parallel (GPU-accelerated) evaluation."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "During the evaluation phase, ExaTN first analyzes the structure of the tensor network in order to determine the pseudo-optimal tensor contraction sequence (contraction path), that is, it performs minimization of the Flop count (or other relevant metrics) necessary for the evaluation of the tensor network as a sequence of pairwise tensor contractions. The Flop count is minimized by using an algorithm based on recursive graph partitioning (via the METIS library [22]) and some heuristics, following an approach similar to the one presented in Ref. [16]. We should note that our default contraction path finder currently does not include Bayesian optimization. Although such a simplified version of the contraction path finder implemented in ExaTN does not provide the top quality, it prioritizes the speed of the tensor contraction path search, to ensure that the search process does not take more time than the actual evaluation of the tensor network on a highly-parallel HPC platform. Furthermore, a common interface for the tensor contraction path optimization provided by ExaTN allows easy integration with existing high-quality tensor contraction path finders, like CoTenGra [16] or cuQuantum [29] (in fact, ExaTN has been integrated with both in experimental branches). Once a pseudo-optimal tensor contraction path has been identified, the ExaTN numerical server executes the determined tensor contraction sequence across multiple nodes with an optional GPU acceleration capability. Each compute node executes its own subset of tensor sub-networks generated by slicing"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 80, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "7"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Q0 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Qk"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 1192, "right": 5616, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 5748, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Gate (1Q)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 920, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Gate (2Q)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 920, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22122"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 5656, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22121"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 5656, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(a)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "notations"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "for"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "qubits, single and two-qubit "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "quantum gates."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 6912, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(b) Tensor network representation of a quantum circuit"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1344, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 1. ExaTN tensor network representation of a quantum circuit."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "some of the tensor network edges, a standard technique used for creating parallel work and reducing the memory footprint of intermediate tensors [16, 37, 38]. It is worth noting that ExaTN supports GPU processing of tensors that are too large to fit into GPU memory. In this case, all cross-device data transfers are orchestrated by the library automatically and transparently to the user. In particular, ExaTN is capable of splitting larger tensors into manageable pieces, automatically transferring tensors to/from GPU memory, prefetching tensors to GPU memory in advance, caching tensors in GPU memory for a subsequent reuse, and pipelining data transfers with computations in order to amortize data transfer overheads."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The direct tensor contraction works best for computing individual amplitudes or their batches. Since the number of open edges in the tensor network is equal to the number of qubits, we cannot obtain the full wave-function for a large number of qubits. Instead, for large-scale circuits, we have implemented a variety of utility functions to extract observable values, as described in Table 1."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.1.1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Single-state amplitudes. Once the full circuit tensor network has been constructed, we can append appropriate conjugate qubit tensors to each open qubit leg to compute a desired quantum state amplitude (as shown in Fig. 2, red triangles project open qubit legs to a specific bit-string)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Effectively, here we construct the following tensor network to evaluate"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 374, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u27e8\u03a8i |Ucircuit |\u03a80\u27e9, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "(1)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 4024, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "where |\u03a80\u27e9 and Ucircuit are the initial state and the equivalent unitary matrix of the quantum circuit, respectively. |\u03a8i\u27e9 is the bit-string state whose amplitude we want to calculate. The result of (1) is just a scalar. This procedure can be repeated for different amplitudes. It is worth noting that despite"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "8"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 76, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Table 1. Tensor Network utility functions for evaluating observables for large-scale quantum circuits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Mode"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 100, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Description"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 100, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Single-state am-plitudes"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 100, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Closing the quantum circuit tensor network with a \u27e8\u03a8i |, where \u03a8i represents a chosen bit-string state, i."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Expectation "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "value by conju-gate"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 6}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Adding a tensor network which represents the observable and then closing with the conjugate quantum circuit (plus light-cone simplifica-tion)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 100, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Expectation "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "value by state vector slicing"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 6}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "A subset of open tensor legs is projected to a bit-string to keep the number of open legs within the memory constraints. Accumulating the expectation values computed on the partial state vector slices for all possible projected bit-strings to compute the overall expectation value."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 96, "right": 94, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Direct unbiased bit-string "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "sam-pling"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 100, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Connecting the quantum circuit tensor network with its conjugate while leaving a subset of qubit legs open to compute the reduced density matrices (marginals) for bit-string sampling and measurement projection."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 92, "right": 100, "firstLine": 8}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "its low rank, the numerical evaluation of a single-state amplitude for large-scale quantum circuits involving many qubits and gates is numerically challenging [38]. Small gate tensors are contracted internally to form larger tensors and any intermediate tensors that require more memory than available will be split into smaller slices and distributed across multiple MPI processes. In principle, this allows simulating output amplitudes of an arbitrarily large quantum circuit in terms of the number of qubits involved, while keeping a bounded memory footprint. The individual or small-batch amplitude evaluation plays a key role in validating near-term quantum hardware via procedures such as the random quantum circuit sampling protocol [5]."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.1.2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Operator expectation values. A ubiquitous use case in quantum circuit simulation is the calculation of the expectation values of Hermitian operators, i.e.,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u27e8\u03a8f |H |\u03a8f \u27e9, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "(2)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 4230, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "where |\u03a8f \u27e9 = Ucircuit |\u03a80\u27e9 is the final state of the qubit register and H is a general Hermitian operator representing an observable of interest. For instance, H could be a Hermitian sum of products of Pauli operators, {\u03c3I,\u03c3X,\u03c3Y ,\u03c3Z }, on different qubits. We have implemented two different methods to compute Eq. (2) for circuits that have more qubits than a state-vector simulator can efficiently handle: (a) via the use of the conjugate tensor network, and (b) via the wave-function slicing approach, as described in Table 1."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "hanging": 8}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "append the measure operator tensors and then close the obtained tensor network with the Hermitian In the first approach, after constructing the tensor network which represents Ucircuit |\u03a80\u27e9, we"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "worst case consists of approximately twice the number of component tensors, as shown in Fig. 3. conjugate of the Ucircuit |\u03a80\u27e9 network. The resulting tensor network evaluates to a scalar and in the"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The evaluation of this tensor network yields the expectation value. It is worth mentioning that ExaTN can intelligently collapse a tensor and its conjugate in case they are contracted with each other, which can therefore simplify the tensor network if the measurement operator product is"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 2032, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 80, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "9"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "0/1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 756, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 2032, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "0/1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 756, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22122"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 698, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "0/1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 756, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22121 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "0/1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 1358, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 2. Single amplitude calculation by tensor network contraction: Open qubit legs are closed with tensors representing the projected 0 or 1 values."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "sparse, i.e., it affects only a small fraction of qubits in the circuit. This simplification is commonly called the light-cone simplification."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In the wave-function slicing evaluation method, we slice the output wave-function based on the memory constraint, compute the expectation value for each slice, and recombine them to form the final result at the end. Specifically, the workflow is as follows"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(1) Based on the memory constraint, determine the max number of open qubit legs (rank_max) in "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "the output tensor."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 328, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(2) Determine the number of wave-function slices (Nslices), which is 2Nprojected, Nprojected = Nqubits \u2212rank_max."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 328, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(3) Distribute the wave-function slice compute tasks (Nslices) across all MPI processes."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 328, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(4) Compute the expectation value of the measurement operator for each slice. (5) Sum (reduce) the partial expectation values to compute the final expectation value."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 328, "right": 1008, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In practice, there are pros and cons in using the above two methods, one based on the quantum circuit conjugation and the other one based on the output wave-function slicing. The first method is more favorable for larger qubit counts (circuit width) and lower circuit depth, in which case the light-cone simplification becomes very effective in reducing the tensor network complexity, provided"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "10"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 64, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q\u20200"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 210, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Observable"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 3274, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Q\u20201 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 444, "right": 432, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22122 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Q\u2020n\u22122 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 364, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Qn\u22121 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Q\u2020n\u22121 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 364, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 3. Expectation value calculation by a double-depth circuit. The observable Pauli tensors {\u03c3k } = {I,X,Y,Z}. Hatched tensors after observable Pauli operators are the conjugates of the ones on the left-hand side."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "that the observable Pauli products are sufficiently local. For deeper quantum circuits and/or less local observables, the light-cone simplification is unable to reduce the computational complexity significantly enough to justify doubling of the tensor network depth. In this case, the second method will be faster, provided that the number of qubits is not too high. On the other hand, both methods are highly amenable to parallelization, and TN-QVM exploits that."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 168, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Matrix Product State Simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "TNQVM also provides an approximate simulator based on the MPS factorization of the circuit wave-function [26], where a user can specify the numerical limit for the singular value truncation as well as the maximum entanglement bond dimension. Built upon the parallel capabilities of ExaTN, we have implemented a distributed MPS tensor processing scheme in which the MPS tensors are distributed evenly across available compute nodes."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 2}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "A quantum circuit simulation via the MPS simulator backend (named exatn-mps) is performed via the standard sequential contraction and decomposition steps [26]. Single-qubit gate tensors can be absorbed into the qubit MPS tensors directly. The application of the two-qubit entangling gates on two neighboring MPS tensors is computed by:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 Merge (contract) the two MPS tensors with the rank-4 gate tensor."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 Decompose the resulting tensor back into two MPS tensors via the singular value decomposition "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "API (exatn::decomposeTensorSVDLR) of ExaTN."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 Truncate the dimension of the connecting leg between the two post-SVD MPS tensors, the so-called bond dimension, according to chosen numerical accuracy or memory constraint settings."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 662, "right": 174, "hanging": 178}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 Update the MPS ansatz with the new MPS tensors."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Kraus Tensor"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1172, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "11"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 650, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 6414, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1994, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 354, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 650, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1994, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c3k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 650, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q3"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1994, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Kraus Tensor"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 6132, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c3k (a) Cartoon of a density matrix simulation. The circles represent a "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "tensor product of unentangled qubit density matrices, the adjoint "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "action of one and two qubit unitaries is indicated by the rounded "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "rectangles, and the local Kraus superoperators are U-shaped tensors."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 1296, "firstLine": 7704}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(b) Expectation value by trace"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 760, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 4. TNQVM density matrix simulation with noise inclusion"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "By following this procedure, we can compute the MPS tensor network approximating the full state vector at the end of the quantum circuit. Expectation values or bit-string amplitudes can be computed in the same manner as previously described for the full tensor network contraction strategy. We also want to note that the transformation of quantum circuits into this nearest-neighbor form by injecting the SWAP gates is performed automatically by the XACC IRTransformation service when the exatn-mps backend is selected."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 170, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In our implementation of the distributed MPS algorithm each MPI process holds a sub-set of MPS tensors (Nqubits/Nprocesses). Multiple process groups (exatn::ProcessGroup) are then created where each process group consists of a pair of neighboring MPI processes to facilitate local communication. The application of entangling gates between neighboring tensors on different MPI processes is performed by:"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 Use exatn::replicateTensor API within a pair of neighboring MPI processes to broadcast "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "the MPS tensor right-to-left."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022 The left process (smaller MPI rank) performs the contraction and SVD decomposition locally.\u2022 The resulting right tensor will then be forwarded left-to-right using exatn::replicateTensor. "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "The two processes now decouple and can continue their independent processing of gates on "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "their subset of managed qubits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 484, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "12"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 236, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 178, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 96, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 1052, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Kraus"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 244, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 110, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 146, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 236, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 178, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Contract"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 3060, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 96, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 356, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Merged"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 232, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "SVD"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K\u2032"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 124, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 236, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 188, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 96, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "K"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "D"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 356, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "SVD"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 128, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\ufffdT3"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 236, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "T3"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 188, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(b) Contract a Kraus tensor and decompose"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 898, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(SVD) back to the locally-purified matrix prod-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 870, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "(a) Locally-purified MPS tensor network: K is the Kraus dimension and D is the bond dimen-sion."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 898, "right": 144, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "uct state form. The Kraus dimension is up-dated (K to K\u2032after the SVD decomposition."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 864, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 5. Locally-purified matrix product state tensor network representation."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.3 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Density Matrix Simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In TNQVM, we can also construct the density matrix by taking the outer product of a state vector with its dual. In this form the density matrix tensor has a rank of 2N (number of dimensions), with N being the number of qubits. Using a density matrix representation of the quantum state, we can thus incorporate (non-unitary) noise processes into the simulation workflow. A convenient representation for noise processes (channels) is the Kraus expansion,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 170, "firstLine": 8}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u03c1 \ufffd\u2192\ufffdAk\u03c1A\u2020k, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "(3)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 4020, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "k"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 4768, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "where \u03c1 = |\u03a8\u27e9\u27e8\u03a8| is the density matrix and {Ak} is the set of Kraus operators, satisfying\ufffdkA\u2020kAk = 1, describing the channel of interest."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "hanging": 8}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "To simulate noisy quantum circuits via our exatn-dm backend, we append gate tensors to both sides of the tensor network representing the density matrix. Specifically, for each quantum gate, the gate tensor and its conjugate are applied to the ket (right) and bra (left) sides, respectively. Noise operators, on the other hand, are tensors that need to be connected to both ket and bra legs as shown in Fig. 4a. We want to note that for illustration purposes, noise tensors are represented as U-shaped tensors in Fig. 4a. We construct them as rank-4 and rank-8 tensors for single- and two-qubit noise processes, respectively, and then append them to our tensor network. In our examples, we have defined depolarizing and dephasing Kraus tensors. To formally construct these tensors, we contract (trace over) an environmental qubit in a dilated unitary formulation [28]."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "13"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Following this construction procedure, we have a full tensor network capturing the noisy evolu-tion according to the input quantum circuit and a given noise model. At this point, we can evaluate this tensor network to retrieve the density matrix, whose diagonal elements equal the probability of measuring a particular computational basis state. For larger systems, however, full density matrix contraction is not practical due to memory con-straints. We can compute specific quantities such as bit-string probabilities or expectation values by adding projection or observable tensors and then contracting the bra and ket qubit legs to form a trace value as depicted in Fig. 4b. The final tensor network is then submitted to ExaTN, which will analyze the structure of the network to determine the tensor contraction sequence and perform the evaluation similar to the simulation algorithm de-scribed in Sec. 3.1."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Using the exatn-dm backend of TNQVM, users can incorporate quantum noise models into the simulation workflow, such as those that mimic the IBM-Q hardware backends. XACC provides utilities to convert IBM's JSON-based backend configurations into concrete relaxation and depo-larization Kraus tensors which are subsequently incorporated into the density matrix tensor net-work as illustrated in Fig. 4."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.4 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Locally-Purified "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "Matrix Product Operator Simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 1008, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Just as one can factorize a full state vector into an MPS tensor network, one can also factorize the full density matrix tensor (as described in Sec. 3.3) into a similar structure. One method, known as the locally-purified matrix product state (LP-MPS) ansatz [40], is depicted in Fig. 5a. It is implemented in TNQVM via another simulation algorithm, named exatn-pmps, that performs ap-proximate density matrix-based simulation follow-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 200}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "#include \"xacc.hpp\""}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "int main(int argc, char **argv) { // Initialize the XACC Framework xacc::Initialize(argc, argv);"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 720, "hanging": 216}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Use ExaTN based TNQVM Accelerator auto qpu = "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "xacc::getAccelerator(\"tnqvm:exatn\", "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "{{\"shots\", 1024}});"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Create a Program "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "auto xasmCompiler = "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "xacc::getCompiler(\"xasm\"); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "std::shared_ptr<IR> ir = "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "xasmCompiler->compile( "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "R\"(__qpu__ void Bell(qbit q) { "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "H(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "CX(q[0], q[1]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Measure(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Measure(q[1]); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "})\", qpu); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "std::shared_ptr<CompositeInstruction> program = ir->getComposite(\"Bell\"); // Allocate a register of 2 qubits auto qubitReg = xacc::qalloc(2); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Execute "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "qpu->execute(qubitReg, program); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Print the result in the buffer."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "qubitReg->print();"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Finalize the XACC Framework xacc::Finalize();"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 864, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "return 0; "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "}"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 3168, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 6. Code snippet demonstrating TNQVM usage with"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "XACC."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 110, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ing this decomposition procedure (this particular algorithm does not support distributed execution yet)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "14"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The application of quantum gates is similar to the MPS algorithm, as described in Sec. 3.2. Two-qubit gates are contracted with the LP-MPS tensors, denoted by Ti, to form a merged tensor which is then decomposed into the canonical tensor product. This procedure only modifies the virtual bond dimension D (see Fig. 5a between the neighboring LP-MPS tensors) which captures the systems entanglement properties. To simulate a non-unitary channel Kraus tensors, such as the ones shown in Fig. 4a, are contracted with the qubit legs of the MPS tensor and its conjugate, see Fig. 5b. After this contraction, we can apply SVD along the Kraus dimension to recover the canonical (locally-purified) form of the LP-MPS factorization. The Kraus dimension (K) between the MPS tensor and its conjugate, encoding statistical mixture in the density operator, is updated after each noise operator iteration."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 206}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.5 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Generic Tensor Network Reconstruction Based Simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The most recent quantum circuit simulation algorithm implemented in TNQVM is based on the ability to reconstruct an arbitrary tensor network (the whole quantum circuit or any of its parts) as another tensor network with a different, presumably simpler topology. This advanced capability is provided by the ExaTN library (exatn::TensorNetworkReconstructor used in the ExaTN-Gen algorithm in TNQVM). In one of the most straightforward settings [26], that is currently implemented in TNQVM, a quantum circuit can be split into chunks of constant depth. Then, by keeping the quantum circuit wave-function (or density matrix, in general) in a factorized form (by some tensor network, e.g., matrix-product state or tensor tree state), each step of this simulation algorithm consists of (A) applying the next quantum circuit chunk to the input tensor network by simply joining both tensor networks, (B) projecting the obtained product on another tensor network of the same or different topology and configuration. The projection step consists of closing the product tensor network with another tensor network and optimizing the tensors in the latter tensor network to maximize the overlap (reconstruction fidelity). At the end of the reconstruction step, the new tensor network approximates the action of a given chunk (slice) of the quantum circuit on the previous wave-function (previous tensor network state). The total reconstruction fidelity for the entire quantum circuit will be a product of reconstruction fidelities for all reconstruction steps, thus providing a user with a quantitative measure of simulation quality (approximation error). In the current implementation, this algorithm in TNQVM has two built-in tensor network topologies, matrix product state and tensor tree state. In general, a user can extend this algorithm to other topologies by providing specialized tensor network builders. Furthermore, one can implement more sophisticated simulation algorithms using this general tensor network reconstruction procedure, in which the quantum circuit is partitioned in a more clever way (the work in this direction is currently in progress)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 172, "right": 144, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "DEMONSTRATIONS"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this section, we seek to demonstrate the utility, flexibility and performance of some of the ExaTN-based backends implemented in TNQVM, while also providing relevant code snippets."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.1 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Quantum circuit simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "As a first example, Fig. 6 shows a typical usage of TNQVM as a virtual Accelerator in the XACC framework. In particular, after TNQVM is compiled and installed to the XACC plugin directory, users can use xacc::getAccelerator API to retrieve an instance of the TNQVM accelerator using the"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "hanging": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "15"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "name key tnqvm. In addition, one of the backends described in Section 3 can be specified after the ':'symbol. For example, the code snippet in Fig. 6 calls for the full tensor network contraction simulator (exatn)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 152, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Query the noise model from an IBM device auto noiseModel = "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "xacc::getService<xacc::NoiseModel>(\"IBM\"); noiseModel->initialize( "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "{{\"backend\", \"ibmqx2\"}}); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "auto qpu = xacc::getAccelerator( "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "\"tnqvm:exatn-dm\", "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "{{\"noise-model\", noiseModel}});"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "auto qubitReg = xacc::qalloc(1);"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Create a test program: "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Apply back-to-back Hadamard gates "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// to assess gate noise "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "auto xasmCompiler = xacc::getCompiler(\"xasm\"); auto ir = xasmCompiler->compile(R\"( "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "__qpu__ void conjugateTest(qbit q) { "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "for (int i = 0; i < NB_CYCLES; i++) { "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "H(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "H(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "} "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Measure(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "})\", qpu);"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 7. Noisy quantum circuit simulation with TNQVM. The device noise model (IBMQ Yorktown, ibmqx2) is generated from online calibration data and provided to TNQVM as a noise-model configuration. In this code snippet, we show the experiment on the first qubit (q[0]) of the device. Other qubits can also be experimented with similarly by specifying their in-dices. Here, we only show a snippet of the code, not including header files and other initialization/finalization steps."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Any specialized configurations are given in terms of a dictionary (key-value pairs) when requesting the accelerator. For ex-ample, we can specify the number of sim-ulation runs (shots), as shown in Fig. 6. There are a lot of configurations specific to each simulator backend documented on the XACC documentation website. Sim-ulation results, e.g., shot count distribu-tion, are persisted to the qubit register (xacc::AcceleratorBuffer) for later re-trieval or post-processing."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The above example demonstrates the seamless integration of TNQVM and all of its backends into the XACC stack. All user codes can use TNQVM as a drop-in replacement for the backend Acceler-ator. Furthermore, when the simulation de-mands an HPC platform, users will get in-stant scalability, i.e., no code changes re-quired, thanks to the TNQVM-ExaTN ab-straction layer."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 68, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.2 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Noisy simulation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 68, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "One of the advantages of being part of the XACC framework is that TNQVM can query device characteristics of hardware back-ends, e.g., IBMQ devices, from XACC to per-form hardware emulation. Since TNQVM fully supports noisy quantum circuit simula-tions, local noise channels can be incorpo-rated into the simulation process. In Fig. 7, we show a simple example how one can"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "construct a noise model from the IBMQ ibmqx2 (Yorktown) device configuration via the XACC NoiseModel utility, followed by the initialization of the density matrix based backend of TNQVM (exatn-dm, see Sec. 3.3)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this demonstration, we simulate a simplified randomized benchmarking procedure whereby the gate set only contains a single gate (Hadamard). By repeating this gate back-to-back over multiple cycles, we can quantify the gate noise in terms of deviation from an ideal identity operation. In other words, if the Hadamard gate is ideal, we would see the qubit state stays at 0 (\u27e8Z\u27e9 = 1) regardless of"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 170, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}, {"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "16"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "the number of gates. However, due to device noise, we expect a decay of the ground state population"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "as the number of cycles increases, and we see this in the resultant data shown in Fig. 8."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In this experiment, we test the Hadamard gate sequence on both"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Benchmarking of noisy Hadamard gates with TNQVM"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "qubit 0 and 1, which have a quite sig-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 324, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 204, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 224, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "nificant single-qubit gate fidelity dif-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ference (8.906e-4 for Q0 and 1.935e-3"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "for Q1). It is worth noting that these "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "0.8 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "calibration parameters are provided"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 5040, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "by IBM in real-time, which XACC uses to construct the NoiseModel object."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "0.6"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "\u27e8Zi\u27e9"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 106, "right": 2448, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The simulation results from TNQVM,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "as shown in Fig. 8, are consistent "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "0.4"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "with the device characteristics. We"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "can clearly see a much faster decay"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "0.2"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 4, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "0"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 14, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "100"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "200"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "300"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "400"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "500"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "600"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "700"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 146, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "for Q1, whose gate error rate is re-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ported to be more than double that of"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Q0."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Using the matrix trace bra-ket con-nection, as depicted in Fig. 4b, we can simulate noisy quantum circuits that contain a large number of qubits as low-rank tensor networks. Intermedi-ate tensor slices appearing in these large-scale tensor network contrac-tions can be effectively distributed"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Sequence length (NB_CYCLES)"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 1282, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 8. Plots of expectation values of Pauli-Z operator vs the length"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "of the H-H sequence (NB_CYCLES in Fig. 7). Since TNQVM simulates"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "all noise channels according to the device model (ibmqx2), the \u27e8Z\u27e9"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "expectation decays as the number of cycles increases. Calibration"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "data: Single qubit Pauli-X error: 8.906e-4 (Q0) and 1.935e-3 (Q1)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "across many compute nodes by ExaTN."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.3 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Single amplitude calculation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In order to demonstrate the parallel performance and efficient use of GPU by the TNQVM-ExaTN simulator, here we examine the run time of the direct tensor contraction algorithm when simulating a single output state amplitude (see Table 1) for the Sycamore random quantum circuits involving 53 qubits [4]. The code snippet setting up the simulation experiment is shown in Fig. 9, whereby we can recognize the familiar Accelerator initialization, AcceleratorBuffer allocation, and execution workflow patterns. The only difference is that we provide a bit-string initialization parameter to request that the amplitude of that specific bit-string be computed."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "The Sycamore test circuits involve a large number of qubits (53), thus making the full state-vector calculation unfeasible. Instead, we use the projection, as shown in Fig. 2, to compute the amplitude of a particular bit-string of interest. Also, since we intended to run this test on a cluster, configurations such as the RAM buffer size per MPI process can be customized when initializing the TNQVM accelerator. The random quantum circuit (program variable in Fig. 2) is adopted from the Google's quantum supremacy experiment [4] in which the ideal simulation of the depth-14 circuit on Summit was already considered prohibitively expensive at that time. The performance results for"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 144, "firstLine": 206}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "17"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Compute the amplitude of a bit-string: "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// BIT_STRING is a vector of length 53, e.g. 000000000...00 // represents the state whose amplitude we want to compute."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 2592, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "auto qpu = "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "xacc::getAccelerator(\"tnqvm:exatn\", {{\"bitstring\", BIT_STRING}, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "{\"exatn-buffer-size-gb\", 2}}); // Allocate a register of 53 qubits (Sycamore chip) "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "auto qubitReg = xacc::qalloc(53); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Program is the random quantum circuit."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 1296, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "qpu->execute(qubitReg, program); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Retrieve the amplitude result "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "const double realAmpl = (*qubitReg)[\"amplitude-real\"].as<double>(); const double imagAmpl = (*qubitReg)[\"amplitude-imag\"].as<double>();"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 1728, "firstLine": 0}}}]}]}]}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "9. Simulating"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "a"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Sycamore"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "bit-string"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "amplitude"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "with"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "TNQVM."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Variable"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "program"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "is"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "an"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "XACC's"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "CompositeInstruction instance compiled from the Sycamore test circuits. Here, we only show a snippet of the code, not including header files and other initialization/finalization steps*."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "*Code for this example is available at"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "the depth-14 Sycamore random quantum circuit are listed in Table 2. Our compilation of the circuit comprises 2828 quantum gates, a higher count than originally reported because some 1-body gates had to be additionally decomposed inside XACC, which does not affect computational complexity (the number of two-body gates is the same)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 168, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Table 2. Performance comparison of simulating a single amplitude of the depth-14 2D random quantum circuit with 53 qubits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 144, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "System"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Precision"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Time to"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 336, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Avg."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 406, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Flop count"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Bit-string"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "solution [s]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 272, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tflop/s/GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 190, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "per GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "amplitude"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "DGX-A100, 8 A100 GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 162, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2003.23"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 104, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "15.06"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 194, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.0160E+16"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4899E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": []}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "TF32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 162, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "868.38"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 104, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "34.73"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 194, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.0160E+16"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4840E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "DGX-1, 8 V100 GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "13028.92"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 352, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.05"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 424, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.9791E+16"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4896E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "OLCF Summit"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 756, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "16 nodes, 96 V100 GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 206, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "695.5"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.03"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 264, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.7995E+15"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4899E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "64 nodes, 384 V100 GPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 206, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "125.52"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.85"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 264, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.0856E+14"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4899E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}, {"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "64 nodes, 384 V100 GPU1"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 104, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 206, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "60.695"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "7.99"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 264, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.8508E+14"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4900E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Dual AMD Rome CPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 380, "right": 0, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1 node, 2 x 64-core CPU"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "FP32"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "40571.412"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2.98"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 264, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3.0160E+16"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 276, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "6.4899E-09"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "1Faster tensor network contraction path "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "2Extrapolated after 2-hour execution"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 6192, "hanging": 4}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "18"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 84, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "As seen from Table 2, on Summit3we observe an excellent strong scaling (from 16 to 64 nodes) as well as a reasonably good absolute efficiency (27 - 53% of the theoretical FP32 peak per GPU). The sec-ond 64-node experiment on Summit used a faster tensor contraction path which took longer to find as the price to pay. The 16-node and the first 64-node experiments spent less time in the tensor contraction path search than in its actual execution, whereas the second 64-node experiment spent more time in finding a faster tensor contraction path than in its actual execu-tion (this contraction path also turned out to deliver a better Flop efficiency). In all these experiments we used an out-of-core tensor contraction algorithm implemented in ExaTN, in which the participating ten-sors may exceed the GPU RAM limit as long as they fit in a normally larger Host RAM. The performance of this algorithm can easily become bound by the Host-to-Device data transfer bandwidth that can be clearly seen from the DGX-14results"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 200}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "// Create a Program "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "auto program = xasmCompiler->compile( "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "R\"(__qpu__ void entangle(qbit q) { "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "H(q[0]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "for (int i = 1; i < 60; i++) { "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "CX(q[0], q[i]); "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "} "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "})\")->getComposite(\"entangle\"); "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "const int NB_QUBITS = 60; "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Measure 2 random qubits & compute marginal // wavefunction slice of 2 random qubits (Q2&Q47) BIT_STRING[2] = -1; "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "BIT_STRING[47] = -1; "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// Note: Other bits in the BIT_STRING "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// array can be set to 0 or 1 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "// to denote their projection values."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "auto qpu = "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "xacc::getAccelerator(\"tnqvm:exatn\", "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "{{\"bitstring\", BIT_STRING}}); // Allocate qubit register and execute auto qubitReg = xacc::qalloc(NB_QUBITS); qpu->execute(qubitReg, program);"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 60, "right": 576, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Fig. 10. Compute the marginal wave function slice for a subset"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 122, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "of qubits (2) out of a qubit register of size 60. The qubits are ini-"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 122, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "where GPUs communicate with the CPU "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "tialized to a cat state. Here, we only show a snippet of the code, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "not including header files and other initialization/finalization Host via the slower PCIe-3 bus instead of "}, {"TYPE": "Break"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "steps."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "faster NVLink-2. Combined with a lesser amount of Host RAM per MPI process (8 MPI processes on 8 V100 GPUs versus 6 MPI processes on 6 V100 GPUs on Summit), it resulted in a significant performance drop, down to about 20% of the absolute FP32 peak per GPU. On the other hand, the new DGX-A100 box5with 2 TB of Host RAM and 80 GB RAM per GPU, as well as with a faster PCIe-4 bus, delivers much better FP32 performance for the out-of-core algorithm. Furthermore, the new A100 tensor cores running with the TF32 precision bump up the performance with an impressive additional 2.3X speed up while keeping the result correct to 3 decimal digits. Despite such a great performance of the out-of-core algorithm on DGX-A100 with a quickly generated, but suboptimal tensor contraction sequence, the simulation of the Sycamore random quantum circuits with a higher depth will result in a computational workload with a lower arithmetic intensity, necessitating the full"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 328, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "3Summit node: 2 IBM Power9 CPU with 21 cores each, 6 NVIDIA V100 GPU with 16 GB RAM each, NVLink-2 all-to-all, 512 GB Host RAM "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "4DGX-1 node: 2 Intel Xeon E5-2698 CPU with 20 cores each, 8 NVIDIA V100 GPU with 32 GB RAM each, PCIe-3 bus between CPU and GPU, 512 GB Host RAM "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "5DGX-A100 node: 2 AMD Rome CPU with 64 cores each, 8 NVIDIA A100 GPU with 80 GB RAM each, PCIe-4 bus between CPU and GPU, 2 TB Host RAM"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 170, "right": 288, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "19"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "transition of all tensors into the GPU RAM (in-core). For this purpose, we have already integrated TN-QVM with the NVIDIA cuQuantum framework and are looking forward to benchmark it soon."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 144, "firstLine": 6}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "4.4 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Marginal wave-function slice calculation"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Similar to the bit-string amplitude calculation (Fig. 9), one can also use TNQVM to compute a marginal wave-function (state-vector) slice for a subset of qubits given other qubits are projected to classical 0 or 1 states. In particular, by keeping a set of n qubits open, the computed vector slice will have a length of 2n, representing the marginal (conditional) wave function of these qubits given other qubits are fixed. This calculation applies to the chaotic sampling of random quantum circuits or divide-and-conquer parallelization of the state-vector based simulation."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 174, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Fig. 10 demonstrates the use of this calculation for a many-qubit cat state, namely, the state "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "1 "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "|\u03a8\u27e9 =\u221a2(|00..00\u27e9 + |11..11\u27e9). This state is generated by the Hadamard gate followed by a sequence of entangling CNOT gates. For demonstration purposes, we randomly selected two open qubits, 2 and"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 94, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "47, to compute the wave-function slice. Thus, the result vector is expected to have a length of 4 and will be returned in the AcceleratorBuffer."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 144, "firstLine": 2}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "In TNQVM, we use a special value of -1 to denote open qubits in the input bit-string. Other qubits are projected to either 0 or 1 values as specified in the bit-string. For instance, given the cat-state, only when other qubits are all 0's or all 1's, then the marginal wave-function result is non-zero. And, we get a marginal state vector of [1,0,0,0] or [0,0,0,1] for the two cases of all others are 0's or all 1's, respectively. This confirms the expected entanglement property of the cat state. As reported in Ref. [31], we can further draw bit-string samples from the resulting marginal wave-function slice to simulate sampling from a subspace of the total Hilbert space determined by those projected qubits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 166, "right": 0, "firstLine": 200}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "5 "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "CONCLUSIONS"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "We have introduced a general tensor network based quantum circuit simulator capable of modeling both ideal and noisy quantum circuits as well as computing various experimentally accessible properties depending on the tensor network formalism used. The versatility and scalability of the ExaTN numerical backend used by this new re-architected version of TNQVM enables simulations of large-scale quantum circuits on leadership HPC platforms. In addition, we have also demonstrated algorithms that incorporate noisy dissipative processes into the simulations."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 174, "hanging": 10}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "TNQVM provides a number of capabilities allowing users to efficiently calculate expectation values, exactly or approximately, generate unbiased random measurement bit-strings, or compute state-vector amplitudes. These properties are pertinent to near-term experimental endeavors, such as studying the variational quantum algorithms and validating the new quantum hardware. In this respect, TNQVM presents itself as a valuable tool for analysis and verification of quantum algorithms and devices in pursuit of advancing the progress towards large-scale, fault-tolerant quantum computing. Our continuous goal is to keep extending the functionality of TNQVM and ExaTN by incorporating new and more efficient tensor-based techniques into the simulation workflow in order to enable classical simulation of larger and deeper quantum circuits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 166, "firstLine": 206}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACKNOWLEDGMENTS"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "This work has been supported by the US Department of Energy (DOE) Office of Science Advanced Scientific Computing Research (ASCR) Quantum Computing Application Teams (QCAT), Accelerated"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "20"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 88, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Research in Quantum Computing (ARQC), and National Quantum Information Science Research Centers. The development of the core capabilities of the ExaTN library was funded by a laboratory directed research and development (LDRD) project at the Oak Ridge National Laboratory (LDRD award 9463). This research used resources of the Oak Ridge Leadership Computing Facility, which is a DOE Office of Science User Facility supported under Contract DE-AC05-00OR22725. Oak Ridge National Laboratory is managed by UT-Battelle, LLC, for the US Department of Energy under contract no. DE-AC05-00OR22725. We would also like to thank Tom Gibbs and NVIDIA for providing access to the DGX-A100 computational resources for performance benchmarking."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 168, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "REFERENCES"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[1] 2020. ExaTN library: Exascale Tensor Networks. "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[2] Scott Aaronson and Daniel Gottesman. 2004. Improved simulation of stabilizer circuits. Phys. Rev. A 70 (Nov 2004), "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "052328. Issue 5. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[3] QIR Alliance. [n.d.]. Quantum Intermediate Representation. https://github.com/qir-alliance/qir-spec."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 266, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[4] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando GSL Brandao, David A Buell, et al. 2019. Quantum supremacy using a programmable superconducting processor. Nature 574, 7779 (2019), 505-510."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 548, "right": 144, "hanging": 282}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[5] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Fernando G. S. L. Brandao, David A. Buell, and et al. 2019. Quantum supremacy using a programmable superconducting "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "processor. Nature 574, 7779 (Oct 2019), 505-510. "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[6] Ryan S. Bennink, Erik M. Ferragut, Travis S. Humble, Jason A. Laska, James J. Nutaro, Mark G. Pleszkoch, and Raphael C."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 266, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Pooser. 2017. Unbiased simulation of near-Clifford quantum circuits. Phys. Rev. A 95 (Jun 2017), 062337. Issue 6."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 548, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[7] Sergey Bravyi, Dan Browne, Padraic Calpin, Earl Campbell, David Gosset, and Mark Howard. 2019. Simulation of "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "quantum circuits by low-rank stabilizer decompositions. Quantum 3 (Sept. 2019), 181. "}, {"TYPE": "TabChar"}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[8] Sergey Bravyi and David Gosset. 2016. Improved Classical Simulation of Quantum Circuits Dominated by Clifford Gates."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 266, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Phys. Rev. Lett. 116 (Jun 2016), 250501. Issue 25. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[9] Aidan Dang, Charles D. Hill, and Lloyd C. L. Hollenberg. 2019. Optimising Matrix Product State Simulations of Shor's "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Algorithm. Quantum 3 (Jan. 2019), 116. "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[10] Hans De Raedt, Fengping Jin, Dennis Willsch, Madita Willsch, Naoki Yoshioka, Nobuyasu Ito, Shengjun Yuan, and Kristel "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Michielsen. 2019. Massively parallel quantum computer simulator, eleven years later. Computer Physics Communications "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "237 (2019), 47-61. "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[11] Matthew Fishman, Steven R. White, and E. Miles Stoudenmire. 2020. The ITensor Software Library for Tensor Network "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Calculations. arXiv: [cs.MS] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[12] Erich Gamma, Richard Helm, Ralph Johnson, and John M. Vlissides. 1994. Design Patterns: Elements of Reusable "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Object-Oriented Software (1 ed.). Addison-Wesley Professional."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[13] Craig Gidney. 2021. Stim: a fast stabilizer circuit simulator. arXiv: [quant-ph] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[14] Ivan Glasser, Nicola Pancotti, and J. Ignacio Cirac. 2019. From probabilistic graphical models to generalized tensor "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "networks for supervised learning. arXiv: [quant-ph] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[15] Johnnie Gray. 2018. quimb: a python library for quantum information and many-body calculations. Journal of Open "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Source Software 3, 29 (2018), 819. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[16] Johnnie Gray and Stefanos Kourtis. 2021. Hyper-optimized tensor network contraction. Quantum 5 (March 2021), 410."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[17] Gian Giacomo Guerreschi, Justin Hogaboam, Fabio Baruffa, and Nicolas P D Sawaya. 2020. Intel Quantum Simulator: a "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "cloud-ready high-performance simulator of quantum circuits. Quantum Science and Technology 5, 3 (may 2020), 034007."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[18] Zhao-Yu Han, Jun Wang, Heng Fan, Lei Wang, and Pan Zhang. 2018. Unsupervised Generative Modeling Using Matrix "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Product States. Phys. Rev. X 8 (Jul 2018), 031012. Issue 3."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Tensor Network Quantum Virtual Machine"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 92, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "21"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[19] Thomas H\u00e4ner and Damian S. Steiger. 2017. 0.5 petabyte simulation of a 45-qubit quantum circuit. Proceedings "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "of the International Conference for High Performance Computing, Networking, Storage and Analysis (Nov 2017)."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[20] Cupjin Huang, Fang Zhang, Michael Newman, Junjie Cai, Xun Gao, Zhengxiong Tian, Junyin Wu, Haihong Xu, Huanjun "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Yu, Bo Yuan, Mario Szegedy, Yaoyun Shi, and Jianxin Chen. 2020. Classical Simulation of Quantum Supremacy Circuits."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "arXiv: [quant-ph] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[21] Wenzel Jakob, Jason Rhinelander, and Dean Moldovan. 2017. pybind11 - Seamless operability between C++11 and "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Python. https://github.com/pybind/pybind11."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[22] George Karypis and Vipin Kumar. 1999. A fast and high quality multilevel scheme for partitioning irregular graphs."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "SIAM Journal on Scientific Computing 20, 1 (1999), 359-392. [23] Ang Li, Omer Subasi, Xiu Yang, and Sriram Krishnamoorthy. 2020. Density Matrix Quantum Circuit Simulation via the "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "BSP Machine on Modern GPU Clusters. In Proceedings of the International Conference for High Performance Computing, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Networking, Storage and Analysis."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[24] Danylo Lykov, Angela Chen, Huaxuan Chen, Kristopher Keipert, Zheng Zhang, Tom Gibbs, and Yuri Alexeev. 2021."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Performance Evaluation and Acceleration of the QTensor Quantum Circuit Simulator on GPUs. In 2021 IEEE/ACM Second International Workshop on Quantum Computing Software (QCS). 27-34. [25] Igor L. Markov and Yaoyun Shi. 2008. Simulating Quantum Computation by Contracting Tensor Networks. SIAM J."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 144, "right": 152, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Comput. 38, 3 (2008), 963-981. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[26] Alexander McCaskey, Eugene Dumitrescu, Mengsu Chen, Dmitry Lyakh, and Travis Humble. 2018. Validating quantum-"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "classical programming models with tensor network simulations. PloS one 13, 12 (2018), e0206704."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[27] Alexander J McCaskey, Dmitry I Lyakh, Eugene F Dumitrescu, Sarah S Powers, and Travis S Humble. 2020. XACC: a system-level software infrastructure for heterogeneous quantum-classical computing. Quantum Science and Technology 5, 2 (2020), 024002."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 548, "right": 174, "hanging": 374}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[28] Michael A. Nielsen and Isaac L. Chuang. 2000. Quantum Computation and Quantum Information. Cambridge University "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Press."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 144, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "[29] NVIDIA. 2021. cuQuantum: Accelerate Quantum Information Science. https://developer.nvidia.com/cuquantum-sdk. [30] Rom\u00e1n Or\u00fas. 2014. A practical introduction to tensor networks: Matrix product states and projected entangled pair "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "states. Annals of Physics 349 (2014), 117-158. "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[31] Feng Pan and Pan Zhang. 2021. Simulating the Sycamore quantum supremacy circuits. arXiv: [quant-ph] [32] Agustin Di Paolo, Thomas E. Baker, Alexandre Foley, David S\u00e9n\u00e9chal, and Alexandre Blais. 2021. Efficient modeling of "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "superconducting quantum circuits with tensor networks. npj Quantum Information 7, 1 (2021). "}, {"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[33] John Preskill. 2018. Quantum Computing in the NISQ era and beyond. Quantum 2 (Aug 2018), 79. "}, {"TYPE": "TabChar"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[34] Justin Reyes and Miles Stoudenmire. 2020. A Multi-Scale Tensor Network Architecture for Classification and Regression."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "arXiv: [stat.ML] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[35] Chase Roberts, Ashley Milsted, Martin Ganahl, Adam Zalcman, Bruce Fontaine, Yijian Zou, Jack Hidary, Guifre Vidal, and "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Stefan Leichenauer. 2019. TensorNetwork: A Library for Physics and Machine Learning. arXiv:[physics.comp-"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "ph] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[36] Y.-Y. Shi, L.-M. Duan, and G. Vidal. 2006. Classical simulation of quantum many-body systems with a tree tensor network."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Phys. Rev. A 74 (Aug 2006), 022320. Issue 2. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[37] Benjamin Villalonga, Sergio Boixo, Bron Nelson, Christopher Henze, Eleanor Rieffel, Rupak Biswas, and Salvatore "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Mandr\u00e0. 2019. A flexible high-performance simulator for verifying and benchmarking quantum circuits implemented on "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "real hardware. npj Quantum Information 5, 1 (2019). "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[38] Benjamin Villalonga, Dmitry Lyakh, Sergio Boixo, Hartmut Neven, Travis S Humble, Rupak Biswas, Eleanor G Rieffel, "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Alan Ho, and Salvatore Mandr\u00e0. 2020. Establishing the quantum supremacy frontier with a 281 Pflop/s simulation."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Quantum Science and Technology 5, 3 (apr 2020), 034003. "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[39] Trevor Vincent, Lee J. O'Riordan, Mikhail Andrenkov, Jack Brown, Nathan Killoran, Haoyu Qi, and Ish Dhand. 2021. Jet: "}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "Fast quantum circuit simulations with parallel task-based tensor-network contraction. (2021). arXiv: [quant-"}, {"TYPE": "TabChar"}, {"TYPE": "text", "VALUE": "ph] "}, {"TYPE": "Break"}, {"TYPE": "text", "VALUE": "[40] Albert H Werner, Daniel Jaschke, Pietro Silvi, Martin Kliesch, Tommaso Calarco, Jens Eisert, and Simone Montangero."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 174, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "2016. Positive tensor network approach for simulating open quantum many-body systems. Physical review letters 116,"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 548, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 174, "firstLine": 0}}}, {"TYPE": "table", "VALUE": [{"TYPE": "table-row", "VALUE": [{"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "22"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "\u2022"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}]}, {"TYPE": "table-cell", "VALUE": [{"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "Thien Nguyen, Dmitry Lyakh, Eugene Dumitrescu, David Clark, Jeff Larkin, and Alexander McCaskey"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 88, "right": 0, "firstLine": 0}}}]}]}]}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "23 (2016), 237201."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 548, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "CT_Empty", "VALUE": "[w:drawing]"}], "style": {"indent": {"TYPE": "CT_Ind", "left": 0, "right": 0, "firstLine": 0}}}, {"TYPE": "paragraph", "VALUE": [{"TYPE": "text", "VALUE": "ACM Trans. Quantum Comput."}], "style": {"indent": {"TYPE": "CT_Ind", "left": 168, "right": 0, "firstLine": 0}}}]}]}